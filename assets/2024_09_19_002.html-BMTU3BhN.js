import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a as h,b as e,d as i,e as n,w as l,r as p,o}from"./app-BemMtkS6.js";const d="/assets/Topical_Communications_Single-GAXanN0n.gif",k="/assets/Topical_Communications_Multiple-khHuCkQW.gif",g="/assets/Topical_Communications_Lost-B6m8Qvl_.gif",c={},m={class:"hint-container tip"};function u(b,s){const a=p("RouteLink");return o(),r("div",null,[s[9]||(s[9]=h('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p><strong>话题通信(Topics)<strong>是一种以发布 <code>订阅</code> 的方式实现不同节点之间数据传输的通信模式。数据发布对象称为发布方，数据订阅对象称之为订阅方，发布方和订阅方通过话题(Topic)相关联，发布方将</strong>消息(Message)<strong>发布在话题上，订阅方则从该话题订阅</strong>消息(Message)</strong>。因此在话题通信中，消息的流向总是单向的。</p><p><img src="'+d+'" alt="单组发布/订阅系节点"></p><p>但是在<strong>话题通信</strong>中发布方与订阅方是一种多对多的关系，也就是说，话题通信的同一话题下可以存在多个发布方，也可以存在多个订阅方，这意味着数据会出现交叉传输的情况。</p><p><img src="'+k+'" alt="多组发布/订阅系节点"></p><p>当然如果没有订阅方，数据传输也会出现丢失的情况。</p><p><img src="'+g+`" alt="发布的信息丢失"></p><p>因此，话题通信一般应用于不断更新的、少逻辑处理的数据传输场景。</p><h2 id="消息接口" tabindex="-1"><a class="header-anchor" href="#消息接口"><span>消息接口</span></a></h2><p>在前文的图中，我们了解到发布/订阅系节点是用<strong>消息(Message)<strong>作为信息载体进行数据传输的。而为了规范格式，消息会使用</strong>消息接口</strong>进行数据的格式定义。关于消息接口的使用有多种方式：</p><ul><li><p>在ROS2中，官方通过 <code>std_msgs</code> 功能包提前封装了一些原生的数据类型,比如：</p><ul><li>String</li><li>Int8</li><li>Int16</li><li>Int32</li><li>Int64</li><li>Float32</li><li>Float64</li><li>Char</li><li>Bool</li><li>Empty</li><li>......</li></ul><p>虽然依据官方设定，这些原生数据类型也可以各自独自作为话题通信的数据载体，不过只单单使用这些数据一般只会包含一个 <code>data</code> 字段，结构会较为简单。而且 <code>std_msgs</code> 包中其他的接口文件也比较简单，而结构的单一便意味着功能上的局限性，使得当我们需要传输一些结构复杂的数据时，就会显得力不从心；</p></li><li><p>在 ROS2 中还预定义了许多<strong>标准话题</strong>消息接口，这在实际工作中有着广泛的应用，比如：</p><ul><li><code>sensor_msgs</code> 包中定义了许多关于<strong>传感器消息</strong>相关的接口（例：雷达、摄像头、点云......）</li><li><code>geometry_msgs</code> 包中则定义了许多<strong>几何消息</strong>相关的接口（例：坐标点、坐标系、速度指令......）</li><li>......</li></ul></li><li><p>如果上述接口文件都不能满足我们的需求，我们也可以自定义接口消息；</p></li></ul><p>因此具体如何选型，可以根据具体情况具体分析。</p><hr><h2 id="话题通信的简单实现" tabindex="-1"><a class="header-anchor" href="#话题通信的简单实现"><span>话题通信的简单实现</span></a></h2><p>现在，我们通过针对<strong>原生消息接口</strong>与<strong>自定义消息接口</strong>进行分别实现，以更加深入了解话题通信。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>在下文中为了便利，将<strong>原生消息接口的实现</strong>称为案例1，将<strong>自定义消息接口的实现</strong>称为案例2，统称为<strong>两个案例</strong>。</p></div><h3 id="流程简介" tabindex="-1"><a class="header-anchor" href="#流程简介"><span>流程简介</span></a></h3><p>两个案例实现的通用主要步骤如下：</p><ol><li>编写发布方实现；</li><li>编写订阅方实现；</li><li>编辑配置文件；</li><li>编译；</li><li>执行。</li></ol><p>当然案例2需要先自定义接口消息，除此之外的实现流程与案例1一致。这两个案例会采用C++和Python分别实现，且二者都遵循上述实现流程。</p><h3 id="准备工作" tabindex="-1"><a class="header-anchor" href="#准备工作"><span>准备工作</span></a></h3><p>终端下创建工作空间：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mkdir</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -p</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ws01_plumbing/src</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">cd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ws01_plumbing/src</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">colcon</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> build</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>进入工作空间的src目录:</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">cd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> src/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>调用如下命令创建之后会用到的接口功能包:</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ros2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> pkg</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> create</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --build-type</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ament_cmake</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> base_interfaces_demo</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>调用如下两条命令分别创建C++功能包和Python功能包:</p><p><strong>C++:</strong></p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ros2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> pkg</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> create</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cpp01_topic</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --build-type</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ament_cmake</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --dependencies</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rclcpp</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> std_msgs</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> base_interfaces_demo</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>Python:</strong></p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ros2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> pkg</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> create</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> py01_topic</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --build-type</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ament_python</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --dependencies</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rclpy</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> std_msgs</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> base_interfaces_demo</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>准备工作到此完毕。</p><hr>`,34)),e("p",null,[s[2]||(s[2]=i("接下来你便可以通过 ",-1)),n(a,{to:"/learningNote/Ros2_Note/co_me/2024_09_22.html"},{default:l(()=>[...s[0]||(s[0]=[i("原生消息接口",-1)])]),_:1}),s[3]||(s[3]=i(" 和 ",-1)),n(a,{to:"/learningNote/Ros2_Note/co_me/2024_09_25_002.html"},{default:l(()=>[...s[1]||(s[1]=[i("自定义消息接口",-1)])]),_:1}),s[4]||(s[4]=i(" 来分别实现话题通信了。",-1))]),s[10]||(s[10]=e("h2",{id:"总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#总结"},[e("span",null,"总结")])],-1)),s[11]||(s[11]=e("p",null,[i("在这一节中，我们系统的阐述了如何依据话题通信相关原理，通过自行操作，依据"),e("strong",null,"原生消息接口"),i("和"),e("strong",null,"自定义消息接口"),i("两种实现方法，实现节点之间简单的话题通信。")],-1)),e("div",m,[s[8]||(s[8]=e("p",{class:"hint-container-title"},"在VSCode中设置代码片段",-1)),e("p",null,[s[6]||(s[6]=i("当我们熟悉上述代码编写流程之后，我们会发现，除了自定义类的不同，实际上同个计算机语言内的代码结构基本相同。为了减少重复代码的编写，提升代码编写效率，我们可以在 VSCode 中设置自定义代码片段来自动为我们生成相应自定义片段。具体可参照",-1)),n(a,{to:"/learningNote/coding_skill/2024_09_23.html"},{default:l(()=>[...s[5]||(s[5]=[i("这里",-1)])]),_:1}),s[7]||(s[7]=i("。",-1))])])])}const F=t(c,[["render",u]]),_=JSON.parse('{"path":"/learningNote/Ros2_Note/co_me/2024_09_19_002.html","title":"ROS2-004-通信机制：话题通信","lang":"zh-CN","frontmatter":{"title":"ROS2-004-通信机制：话题通信","icon":"a-liaotianpinglun","date":"2024-09-19T00:00:00.000Z","category":["Computer","robot","ROS"]},"git":{"createdTime":1726736269000,"updatedTime":1741602495000,"contributors":[{"name":"Jeacson_Snake","username":"","email":"Jeacson_Snake@outlook.com","commits":12}]},"readingTime":{"minutes":4.05,"words":1214},"filePathRelative":"learningNote/Ros2_Note/co_me/2024_09_19_002.md","excerpt":"<h2>简介</h2>\\n<p><strong>话题通信(Topics)<strong>是一种以发布 <code>订阅</code> 的方式实现不同节点之间数据传输的通信模式。数据发布对象称为发布方，数据订阅对象称之为订阅方，发布方和订阅方通过话题(Topic)相关联，发布方将</strong>消息(Message)<strong>发布在话题上，订阅方则从该话题订阅</strong>消息(Message)</strong>。因此在话题通信中，消息的流向总是单向的。</p>\\n<p></p>\\n<p>但是在<strong>话题通信</strong>中发布方与订阅方是一种多对多的关系，也就是说，话题通信的同一话题下可以存在多个发布方，也可以存在多个订阅方，这意味着数据会出现交叉传输的情况。</p>"}');export{F as comp,_ as data};
