import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as h,a as r,b as i,d as e,e as n,w as l,r as p,o as d}from"./app-CM1hd37A.js";const k="/assets/Service_Communications_Single-Dmpt_QnF.gif",o="/assets/Service_Communications_Multiple-BfICAQqo.gif",g={};function c(m,s){const a=p("RouteLink");return d(),h("div",null,[s[7]||(s[7]=r('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p><strong>服务通信(Services)<strong>是一种基于 <code>请求响应</code> 的方式实现不同节点之间数据传输的通信模模式。发送请求数据的对象称为</strong>客户端</strong>，接受请求并发送数据相应的对象称之为<strong>服务端</strong>，与话题通信一样，客户端和服务端也通过话题(Topic)相关联，但是客户端和服务端可以互相进行数据传输交互。因此在服务通信中，消息的流向是双向的。</p><p><img src="'+k+'" alt="单对单发布/服务通信节点"></p><p>在<strong>服务通信</strong>中，服务端与客户端是一种一对多的关系。也就是说，在同一服务话题下，可以存在多个客户端，但只能存在一个服务端。每个客户端都可以向服务端发送请求，也即与该单个服务端之间建立独立的相互通信。</p><p><img src="'+o+`" alt="单对多发布/服务通信节点"></p><p>因此，话题通信一般更适用于偶然的、对实时性有要求、且需要具有一定逻辑处理的数据传输场景。</p><hr><h2 id="服务通信的简单实现" tabindex="-1"><a class="header-anchor" href="#服务通信的简单实现"><span>服务通信的简单实现</span></a></h2><p>现在，我们通过针对以下案例需求进行C++与Python的分别实现，以更加深入了解服务通信。</p><h3 id="案例需求-案例分析" tabindex="-1"><a class="header-anchor" href="#案例需求-案例分析"><span>案例需求&amp;案例分析</span></a></h3><p>需求：编写服务通信，客户端可以提交两个整数到服务端，服务端接收请求并解析两个整数求和，然后将结果响应回客户端。</p><p>分析：在上述需求中，我们需要关注以下三个要素：</p><ol><li>客户端；</li><li>服务端；</li><li>消息载体。</li></ol><h3 id="流程简介" tabindex="-1"><a class="header-anchor" href="#流程简介"><span>流程简介</span></a></h3><p>案例实现前需要自定义服务接口。</p><p>在接口准备完毕后，服务通信实现的主要步骤如下：</p><ol><li>编写服务端实现；</li><li>编写客户端实现；</li><li>编辑配置文件；</li><li>编译；</li><li>执行。</li></ol><p>案例会采用C++和Python分别实现，且二者都遵循上述实现流程。</p><h3 id="准备工作" tabindex="-1"><a class="header-anchor" href="#准备工作"><span>准备工作</span></a></h3><p>终端下创建工作空间：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mkdir</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -p</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ws01_plumbing/src</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">cd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ws01_plumbing/src</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">colcon</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> build</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>进入工作空间的src目录:</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">cd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> src/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>调用如下命令创建之后会用到的接口功能包:</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ros2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> pkg</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> create</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --build-type</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ament_cmake</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> base_interfaces_demo</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>调用如下两条命令分别创建C++功能包、Python功能包及其所需服务端节点:</p><p><strong>C++:</strong></p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ros2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> pkg</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> create</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cpp01_topic</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --build-type</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ament_cmake</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --dependencies</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rclcpp</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> std_msgs</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> base_interfaces_demo</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --node-name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> demo01_server</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>Python:</strong></p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ros2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> pkg</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> create</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> py01_topic</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --build-type</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ament_python</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --dependencies</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rclpy</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> std_msgs</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> base_interfaces_demo</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --node-name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> demo01_server_py</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在接口功能包中自定义服务接口消息文件：</p>`,31)),i("p",null,[s[1]||(s[1]=e("具体实现请参考",-1)),n(a,{to:"/learningNote/Ros2_Note/co_me/2024_10_03_002.html"},{default:l(()=>[...s[0]||(s[0]=[e("这里",-1)])]),_:1})]),s[8]||(s[8]=i("p",null,"准备工作到此完毕。",-1)),s[9]||(s[9]=i("hr",null,null,-1)),i("p",null,[s[4]||(s[4]=e("接下来你便可以通过 ",-1)),n(a,{to:"/learningNote/Ros2_Note/co_me/2024_10_03_003.html"},{default:l(()=>[...s[2]||(s[2]=[e("C++",-1)])]),_:1}),s[5]||(s[5]=e(" 和 ",-1)),n(a,{to:"/learningNote/Ros2_Note/co_me/2024_10_03_004.html"},{default:l(()=>[...s[3]||(s[3]=[e("Python",-1)])]),_:1}),s[6]||(s[6]=e(" 来分别实现服务通信了。",-1))]),s[10]||(s[10]=i("h2",{id:"总结",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#总结"},[i("span",null,"总结")])],-1)),s[11]||(s[11]=i("p",null,"在这一节中，我们系统的阐述了如何依据服务通信相关原理，通过自行操作，实现节点之间简单的服务通信。",-1))])}const y=t(g,[["render",c]]),A=JSON.parse('{"path":"/learningNote/Ros2_Note/co_me/2024_10_03.html","title":"ROS2-005-通信机制：服务通信","lang":"zh-CN","frontmatter":{"title":"ROS2-005-通信机制：服务通信","icon":"a-tongzhitixinglaba","date":"2024-10-03T00:00:00.000Z","category":["Computer","robot","ROS"]},"git":{"createdTime":1727950017000,"updatedTime":1741599203000,"contributors":[{"name":"Jeacson_Snake","username":"","email":"Jeacson_Snake@outlook.com","commits":6}]},"readingTime":{"minutes":2.55,"words":764},"filePathRelative":"learningNote/Ros2_Note/co_me/2024_10_03.md","excerpt":"<h2>简介</h2>\\n<p><strong>服务通信(Services)<strong>是一种基于 <code>请求响应</code> 的方式实现不同节点之间数据传输的通信模模式。发送请求数据的对象称为</strong>客户端</strong>，接受请求并发送数据相应的对象称之为<strong>服务端</strong>，与话题通信一样，客户端和服务端也通过话题(Topic)相关联，但是客户端和服务端可以互相进行数据传输交互。因此在服务通信中，消息的流向是双向的。</p>\\n<p></p>\\n<p>在<strong>服务通信</strong>中，服务端与客户端是一种一对多的关系。也就是说，在同一服务话题下，可以存在多个客户端，但只能存在一个服务端。每个客户端都可以向服务端发送请求，也即与该单个服务端之间建立独立的相互通信。</p>"}');export{y as comp,A as data};
