import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as t}from"./app-BemMtkS6.js";const n="/assets/2026_01_27_000-c8MJHuZ-.gif",r={};function h(l,s){return t(),e("div",null,[...s[0]||(s[0]=[a('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>我们在操作机器人时，通常会使用各种传感器感知机器人周围的物体与机器人的相对位置。不过在未针对传感器进行配置的情况下，传感器只能够返回其自身与物体的相对位置。因此我们需要通过某些特定的转换工程，才可以将该传感器的方位信息，变换物体相对于机器人系统或机器人其它组件的方位信息。在 ROS 中直接封装了相关的模块，其名称为 <code>tf(TransForm Frame)</code></p><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><p>该模块允许用户随时间跟踪多个坐标系。它在拥有 <strong>时间缓冲</strong> 的 <em>树状结构</em> 中维护坐标帧之间的关系，并让用户在 <em>任何</em> 所需的时间点在 <em>任意</em> 两个坐标帧之间变换点、向量等。在ROS中已经提供了同名的库实现，并且随着ROS的迭代，该库升级为了tf2，也即第二代坐标变换库。</p><p>完整的坐标变换实现由 <strong>坐标变换广播方</strong> 结构和 <strong>坐标变换监听方</strong> 结构两部分组成。坐标变换广播方会发布 <strong>坐标系相对关系</strong> 的数据，而坐标变换监听方会订阅多个广播方发布的数据。</p><p>每个坐标变换广播方一般只负责发布 <code>一组</code> 坐标系相对关系，而坐标变换监听方则会将 <code>多组</code> 坐标系相对关系组织为一棵坐标树（该坐标树有且仅有一个根坐标系），以实现任意坐标帧之间坐标点或者向量的变换。但是坐标变换时，需要参考消息数据的时间戳，以保证参与变换的两个坐标帧的时间差在特定的时间范围内，否则坐标变换后所获取的坐标在时间上没有参考性，出现误差。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>ROS中的坐标变换是基于右手坐标系的。</p></div><h2 id="案例尝试" tabindex="-1"><a class="header-anchor" href="#案例尝试"><span>案例尝试</span></a></h2><p>接下来我们会尝试使用官方网站上所提供的<a href="https://docs.ros.org/en/jazzy/Tutorials/Intermediate/Tf2/Introduction-To-Tf2.html" target="_blank" rel="noopener noreferrer">相关案例</a>，以对 <code>tf2</code> 有一个初步的了解。</p><p>首先确认是否安装了该案例的功能包与依赖项，没有就使用以下指令在 bash 中安装：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> apt-get</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> install</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ros-jazzy-rviz2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ros-jazzy-turtle-tf2-py</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ros-jazzy-tf2-ros</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ros-jazzy-tf2-tools</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ros-jazzy-turtlesim</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>或者直接克隆源码在构建也行：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> clone</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> https://github.com/ros/geometry_tutorials.git</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -b</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ros2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>接下来只需要在两个独立终端内，分别启动 <code>turtle_tf2_demo.launch.py</code> 文件与之前使用过的 <code>键盘控制</code> 节点：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ros2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> launch</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> turtle_tf2_py</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> turtle_tf2_demo.launch.py</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ros2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> turtlesim</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> turtle_teleop_key</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在 <code>终端B</code> 内 通过键盘 操控小海龟，此时就会看到如下效果：</p><p><img src="'+n+'" alt="会跟随自控小海龟进行移动的小海龟" title="你不要过来啊！！.gif"></p>',18)])])}const p=i(r,[["render",h]]),k=JSON.parse('{"path":"/learningNote/Ros2_Note/coor_trans/2026_01_28.html","title":"ROS220-ROS2工具：坐标变换（一）简介","lang":"zh-CN","frontmatter":{"title":"ROS220-ROS2工具：坐标变换（一）简介","icon":"map-pin","date":"2026-01-28T00:00:00.000Z","category":["Computer","robot","ROS"]},"git":{"createdTime":1769507700000,"updatedTime":1769507700000,"contributors":[{"name":"Jeacson_Snake","username":"","email":"Jeacson_Snake@outlook.com","commits":1}]},"readingTime":{"minutes":2.54,"words":761},"filePathRelative":"learningNote/Ros2_Note/coor_trans/2026_01_28.md","excerpt":"<h2>简介</h2>\\n<p>我们在操作机器人时，通常会使用各种传感器感知机器人周围的物体与机器人的相对位置。不过在未针对传感器进行配置的情况下，传感器只能够返回其自身与物体的相对位置。因此我们需要通过某些特定的转换工程，才可以将该传感器的方位信息，变换物体相对于机器人系统或机器人其它组件的方位信息。在 ROS 中直接封装了相关的模块，其名称为 <code>tf(TransForm Frame)</code></p>\\n<h2>概念</h2>\\n<p>该模块允许用户随时间跟踪多个坐标系。它在拥有 <strong>时间缓冲</strong> 的 <em>树状结构</em> 中维护坐标帧之间的关系，并让用户在 <em>任何</em> 所需的时间点在 <em>任意</em> 两个坐标帧之间变换点、向量等。在ROS中已经提供了同名的库实现，并且随着ROS的迭代，该库升级为了tf2，也即第二代坐标变换库。</p>"}');export{p as comp,k as data};
